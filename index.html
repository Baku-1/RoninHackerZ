<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>New Hack City - Expanded World</title>
    <!-- Ronin Wallet Widget Script -->
    <script src="https://cdn.skymavis.com/widget/main.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000005; font-family: 'Courier New', Courier, monospace;}
        canvas { display: block; }
        .label, .listener-icon, .player-label {
            color: #fff;
            font-family: 'Courier New', Courier, monospace;
            padding: 5px 10px;
            border-radius: 5px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid;
            text-shadow: 0 0 6px #fff, 0 0 12px currentColor;
            transition: all 0.3s;
            white-space: nowrap;
        }
        .player-label {
            padding: 2px 6px;
            font-size: 0.8em;
            text-align: center;
        }
        .label.scan-highlight {
            transform: scale(1.2);
            box-shadow: 0 0 25px currentColor;
        }
        .listener-icon {
            font-size: 1.5em;
            padding: 8px;
            border-radius: 50%;
            border-color: #00ffde;
            color: #00ffde;
        }
        .listener-icon.high-priority {
            border-color: #ff4400;
            color: #ff4400;
            animation: pulse-red 1s infinite;
        }
        @keyframes pulse-red {
            0% { box-shadow: 0 0 10px #ff4400; }
            50% { box-shadow: 0 0 20px #ff4400, 0 0 5px #fff; }
            100% { box-shadow: 0 0 10px #ff4400; }
        }

        #joystick {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 120px;
            height: 120px;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr 1fr;
            pointer-events: auto;
            opacity: 0.7;
        }
        .joy-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgba(0, 255, 222, 0.2);
            border: 1px solid rgba(0, 255, 222, 0.4);
            color: rgba(255, 255, 255, 0.8);
            font-size: 24px;
            user-select: none;
            cursor: pointer;
        }
        #joy-up { grid-column: 2; grid-row: 1; border-radius: 8px 8px 0 0;}
        #joy-down { grid-column: 2; grid-row: 3; border-radius: 0 0 8px 8px;}
        #joy-left { grid-column: 1; grid-row: 2; border-radius: 8px 0 0 8px;}
        #joy-right { grid-column: 3; grid-row: 2; border-radius: 0 8px 8px 0;}
        
        #toolbar {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 220px;
            height: 220px;
            pointer-events: none;
        }
        .tool-btn {
            position: absolute;
            width: 55px;
            height: 55px;
            background-color: rgba(0, 255, 222, 0.15);
            border: 1px solid rgba(0, 255, 222, 0.5);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            color: #fff;
            text-shadow: 0 0 8px #00ffde;
            cursor: pointer;
            pointer-events: auto;
            transition: all 0.3s;
        }
        .tool-btn:hover { background-color: rgba(0, 255, 222, 0.3); }
        .tool-btn.cooldown, .tool-btn.disabled {
            opacity: 0.4;
            cursor: not-allowed;
            background-color: rgba(100, 100, 100, 0.2);
            transform: scale(0.9);
        }
        .tool-btn.buff-active {
             box-shadow: 0 0 20px #00ffde;
             animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 15px #00ffde; }
            50% { box-shadow: 0 0 25px #00ffde, 0 0 5px #fff; }
            100% { box-shadow: 0 0 15px #00ffde; }
        }
        .tool-btn:nth-child(1) { bottom: 25px; right: 145px; } 
        .tool-btn:nth-child(2) { bottom: 75px; right: 125px; } 
        .tool-btn:nth-child(3) { bottom: 115px; right: 90px; } 
        .tool-btn:nth-child(4) { bottom: 140px; right: 45px; } 
        #deploy-listener-btn { bottom: 150px; right: -5px; }

        #radar {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 150px;
            height: 150px;
            background: radial-gradient(circle, rgba(0, 255, 222, 0.1) 0%, rgba(0, 255, 222, 0) 70%);
            border: 2px solid rgba(0, 255, 222, 0.3);
            border-radius: 50%;
            pointer-events: none;
        }
        #radar-blip {
            position: absolute;
            top: 40%;
            left: 60%;
            width: 8px;
            height: 8px;
            background-color: #ff4400;
            border-radius: 50%;
            box-shadow: 0 0 10px #ff4400;
            opacity: 0;
            transition: opacity 0.5s;
        }
        #radar-blip.active { opacity: 1; }

        #player-info {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 350px;
            color: #fff;
            text-align: right;
            pointer-events: none;
        }
        .player-id-container {
            display: flex;
            justify-content: flex-end;
            align-items: baseline;
            margin-bottom: 8px;
        }
        #player-name {
            font-size: 1.1em;
            text-shadow: 0 0 6px #00ffde;
            word-break: break-all;
        }
        #player-level {
            font-size: 1.0em;
            margin-left: 10px;
            color: #ff4400;
            text-shadow: 0 0 8px #ff4400;
            font-weight: bold;
        }
        #listener-count {
            font-size: 1.0em;
            margin-bottom: 8px;
            color: #00ffde;
        }
        #notoriety-bar-bg {
            width: 100%;
            height: 15px;
            background: rgba(0, 255, 222, 0.1);
            border: 1px solid rgba(0, 255, 222, 0.4);
            border-radius: 8px;
            padding: 2px;
        }
        #notoriety-bar-fill {
            width: 10%;
            height: 100%;
            background: #00ffde;
            border-radius: 6px;
            box-shadow: 0 0 10px #00ffde;
            transition: width 0.5s ease-in-out;
        }
        .modal, #level-overlay, #puzzle-overlay, #faction-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 5, 10, 0.8);
            backdrop-filter: blur(5px);
            color: #00ffde;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-size: 1em;
            text-shadow: 0 0 15px #00ffde;
            z-index: 150;
        }
        #level-overlay, #puzzle-overlay { font-size: 2em; }
        #reward-details {
            font-size: 0.6em;
            margin-top: 15px;
            color: #fff;
            line-height: 1.6;
        }
        #bounty-info {
            font-size: 0.4em;
            margin-top: 15px;
            color: rgba(255,255,255,0.6);
            display: none;
        }
        #level-overlay button, .modal button {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 0.8em;
            background-color: rgba(0, 255, 222, 0.15);
            border: 1px solid rgba(0, 255, 222, 0.5);
            color: #fff;
            border-radius: 8px;
            cursor: pointer;
        }
        
        .modal-content {
            padding: 30px;
            border: 1px solid rgba(0, 255, 222, 0.5);
            background: rgba(0, 5, 10, 0.9);
            box-shadow: 0 0 35px rgba(0, 255, 222, 0.3);
            max-width: 800px;
            width: 90%;
            z-index: 200;
        }
        .modal-content button {
            font-size: 1.1em;
        }

        #landing-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000005; display: flex; align-items: center; justify-content: center; z-index: 100; color: #00ffde; text-align: center;
        }
        .landing-content { max-width: 600px; padding: 20px; border: 1px solid rgba(0, 255, 222, 0.5); background: rgba(0, 10, 20, 0.8); box-shadow: 0 0 25px rgba(0, 255, 222, 0.3); }
        .landing-logo { max-width: 150px; margin-bottom: 1em; }
        .tagline { font-size: 1.2em; color: #fff; margin-bottom: 2em; }
        .instructions { text-align: left; margin-bottom: 2em; border-left: 3px solid rgba(0, 255, 222, 0.5); padding-left: 15px; }
        #connect-wallet-btn { padding: 12px 25px; font-size: 1.1em; font-family: 'Courier New', Courier, monospace; background-color: rgba(0, 255, 222, 0.15); border: 1px solid rgba(0, 255, 222, 0.8); color: #fff; border-radius: 8px; cursor: pointer; text-shadow: 0 0 8px #00ffde; transition: background-color 0.3s; }
        #connect-wallet-btn:hover { background-color: rgba(0, 255, 222, 0.3); }
        .disclaimer { margin-top: 2em; font-size: 0.8em; color: rgba(255, 255, 255, 0.6); }

        #puzzle-container { max-width: 400px; }
        #puzzle-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin-top: 20px; }
        .puzzle-btn {
            width: 100px; height: 100px; background-color: rgba(0, 255, 222, 0.1);
            border: 2px solid rgba(0, 255, 222, 0.5); border-radius: 15px;
            cursor: pointer; transition: all 0.1s;
        }
        .puzzle-btn:hover { background-color: rgba(0, 255, 222, 0.2); }
        .puzzle-btn.lit {
            background-color: #00ffde; box-shadow: 0 0 20px #00ffde;
            transform: scale(1.05);
        }
        #puzzle-status { margin-top: 20px; font-size: 0.8em; height: 30px; }
        
        #bounty-board {
            position: absolute;
            top: 20px;
            left: 85px;
            width: 280px;
            padding: 15px;
            background: rgba(0, 15, 25, 0.85);
            border: 1px solid rgba(0, 255, 222, 0.4);
            color: #fff;
            font-size: 0.9em;
            z-index: 50;
        }
        #bounty-board h3 { margin: 0 0 10px 0; color: #00ffde; text-shadow: 0 0 8px #00ffde; border-bottom: 1px solid rgba(0, 255, 222, 0.4); padding-bottom: 5px; }
        #bounty-board ul { list-style: none; padding: 0; margin: 0; }
        #bounty-board li { padding: 5px 0; border-bottom: 1px solid rgba(0, 255, 222, 0.1); transition: all 0.3s; }
        #bounty-board li.completed { text-decoration: line-through; color: rgba(255, 255, 255, 0.4); opacity: 0.6; }

        #menu-toggle-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 55px; height: 55px;
            background-color: rgba(0, 255, 222, 0.15);
            border: 1px solid rgba(0, 255, 222, 0.5);
            border-radius: 50%;
            font-size: 28px;
            color: #fff; text-shadow: 0 0 8px #00ffde;
            cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            z-index: 101;
        }
        #menu-panel {
            position: absolute;
            top: 85px; left: 20px;
            display: none;
            flex-direction: column;
            gap: 10px;
            background-color: rgba(0, 15, 25, 0.9);
            border: 1px solid rgba(0, 255, 222, 0.4);
            border-radius: 10px;
            padding: 10px;
            z-index: 100;
        }
        .menu-btn {
            width: 55px; height: 55px;
            background-color: rgba(0, 255, 222, 0.15);
            border: 1px solid rgba(0, 255, 222, 0.5);
            border-radius: 50%;
            font-size: 28px;
            color: #fff; text-shadow: 0 0 8px #00ffde;
            cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            text-decoration: none;
        }
        .menu-btn:hover { background-color: rgba(0, 255, 222, 0.3); }
        
        #chat-overlay {
            position: absolute;
            bottom: 20px; left: 20px;
            width: 400px; max-width: 90%;
            height: 300px;
            background: rgba(0, 15, 25, 0.85);
            border: 1px solid rgba(0, 255, 222, 0.4);
            border-radius: 10px;
            display: none;
            flex-direction: column;
            z-index: 90;
        }
        #chat-messages {
            flex-grow: 1;
            overflow-y: auto;
            padding: 10px;
            display: flex;
            flex-direction: column;
        }
        .chat-message { margin-bottom: 5px; line-height: 1.4; }
        .chat-message span { font-weight: bold; }
        #chat-input-container { display: flex; padding: 10px; border-top: 1px solid rgba(0, 255, 222, 0.4); }
        #chat-input { flex-grow: 1; background: rgba(0,0,0,0.5); border: 1px solid #00ffde; color: #fff; padding: 8px; border-radius: 5px; }
        #chat-send-btn { margin-left: 10px; padding: 8px 15px; background: #00ffde; color: #000; border: none; border-radius: 5px; cursor: pointer; }
        
        #faction-overlay .faction-choices, #settings-overlay .faction-choices {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-top: 20px;
        }
        .faction-btn {
            padding: 15px 30px;
            font-size: 1em;
            font-family: 'Courier New', Courier, monospace;
            color: #fff;
            border-radius: 8px;
            cursor: pointer;
            border: 2px solid;
            background-color: rgba(255, 255, 255, 0.05);
            transition: all 0.3s ease;
        }
        .faction-btn:hover { transform: scale(1.05); background-color: rgba(255, 255, 255, 0.1); }
        #settings-overlay input {
            background: rgba(0,0,0,0.5); border: 1px solid #00ffde; color: #fff; 
            padding: 10px; border-radius: 5px; width: 80%;
            text-align: center; font-size: 1.1em; margin-top: 10px;
        }

        #leaderboard-overlay .modal-content { max-width: 500px; }
        .leaderboard-personal-stats {
            display: flex;
            justify-content: space-around;
            padding: 15px;
            margin-bottom: 20px;
            background: rgba(0, 255, 222, 0.05);
            border: 1px solid rgba(0, 255, 222, 0.2);
            border-radius: 8px;
        }
        .leaderboard-personal-stats div { text-align: center; }
        .leaderboard-personal-stats h3 { margin: 0 0 5px 0; font-size: 1em; color: rgba(255,255,255,0.7); }
        .leaderboard-personal-stats p { margin: 0; font-size: 1.5em; font-weight: bold; }
        #top-hackers-list { list-style: none; padding: 0; margin: 0; text-align: left; }
        #top-hackers-list li {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            border-bottom: 1px solid rgba(0, 255, 222, 0.1);
        }
        #top-hackers-list li:last-child { border-bottom: none; }
        .leaderboard-rank { font-weight: bold; color: #ff4400; margin-right: 15px; }
        .leaderboard-name { flex-grow: 1; }
        .leaderboard-score { font-weight: bold; }

    </style>
</head>
<body>
    <div id="radar"><div id="radar-blip"></div></div>
    
    <div id="menu-toggle-btn">☰</div>
    <div id="menu-panel">
        <button id="chat-toggle-btn" class="menu-btn" title="World Chat">💬</button>
        <button id="leaderboard-btn" class="menu-btn" title="Leaderboard">🏆</button>
        <button id="settings-btn" class="menu-btn" title="Settings">⚙️</button>
        <a href="https://discord.gg/m4dhphzW" target="_blank" class="menu-btn" title="Give Feedback on Discord">👾</a>
    </div>

    <div id="bounty-board">
        <h3>BOUNTY BOARD</h3>
        <ul id="bounty-list"></ul>
    </div>

    <div id="player-info">
        <div class="player-id-container">
            <div id="player-name">OFFLINE</div>
            <div id="player-level">LVL 1</div>
        </div>
        <div id="listener-count">Listeners: 5 / 5</div>
        <div id="notoriety-bar-bg"><div id="notoriety-bar-fill"></div></div>
    </div>
    <div id="joystick">
        <div id="joy-up" class="joy-btn">▲</div>
        <div id="joy-left" class="joy-btn">◀</div>
        <div id="joy-right" class="joy-btn">▶</div>
        <div id="joy-down" class="joy-btn">▼</div>
    </div>
    <div id="toolbar">
        <div id="scan-btn" class="tool-btn">📡</div>
        <div id="firewall-btn" class="tool-btn">🔥</div>
        <div id="drain-btn" class="tool-btn">💧</div>
        <div id="ghost-btn" class="tool-btn">👻</div>
        <div id="deploy-listener-btn" class="tool-btn">🔊</div>
    </div>
    <div id="level-overlay">
        <h1 id="level-message"></h1>
        <div id="reward-details"></div>
        <p id="bounty-info"></p>
        <button class="modal-close-btn">Return to City</button>
    </div>

    <div id="puzzle-overlay">
        <div id="puzzle-container">
            <h1>HACK THE VAULT</h1>
            <p id="puzzle-status">Watch the sequence...</p>
            <div id="puzzle-grid"></div>
        </div>
    </div>
    
    <div id="faction-overlay">
        <div class="modal-content">
            <h1>Choose Your Path</h1>
            <div class="faction-choices"></div>
        </div>
    </div>
    
    <div id="leaderboard-overlay" class="modal">
        <div class="modal-content">
            <h1>LEADERBOARD</h1>
            <div class="leaderboard-personal-stats">
                <div>
                    <h3>YOUR INFILTRATIONS</h3>
                    <p id="personal-infiltrations">0</p>
                </div>
                <div>
                    <h3>PLAYER AVERAGE</h3>
                    <p id="average-infiltrations">0.00</p>
                </div>
            </div>
            <h3>TOP 10 HACKERS</h3>
            <ul id="top-hackers-list"></ul>
            <button class="modal-close-btn">Close</button>
        </div>
    </div>
    
    <div id="settings-overlay" class="modal">
        <div class="modal-content">
            <h1>SETTINGS</h1>
            <div>
                <h3>Change Name</h3>
                <input type="text" id="name-change-input" placeholder="Enter new name...">
            </div>
            <div id="settings-faction-section">
                <h3>Join a Faction</h3>
                <div class="faction-choices"></div>
            </div>
            <button id="settings-save-btn">Save & Close</button>
        </div>
    </div>
    
    <div id="chat-overlay">
        <div id="chat-messages"></div>
        <div id="chat-input-container">
            <input type="text" id="chat-input" placeholder="Type a message...">
            <button id="chat-send-btn">Send</button>
        </div>
    </div>

    <div id="landing-overlay">
        <div class="landing-content">
            <img src="https://i.imgur.com/gcy0s2G.png" alt="New Hack City Logo" class="landing-logo" onerror="this.style.display='none'">
            <h1>New Hack City</h1>
            <p class="tagline">An Open World Hacking Adventure on Ronin</p>
            <div class="instructions">
                <p><strong>OBJECTIVE:</strong> Explore the city with other hackers, infiltrate systems, and represent your faction.</p>
                <p><strong>CONTROLS:</strong> Use the joystick to move. Drag on the right side of the screen to look.</p>
            </div>
            <button id="connect-wallet-btn">Connect Ronin Wallet</button> 
            <p class="disclaimer">This is a multiplayer pre-alpha community test. Features and assets are not final.</p>
        </div>
    </div>

    <div id="message-modal" class="modal">
        <div class="modal-content">
            <h2 id="modal-title">ALERT</h2>
            <p id="modal-text"></p>
            <button class="modal-close-btn">OK</button>
        </div>
    </div>
    
    <div id="refinement-modal" class="modal">
        <div class="modal-content" id="refinement-menu">
             <h2>REFINEMENT</h2>
            <div class="coming-soon-overlay">
                <h2>COMING SOON</h2><button class="modal-close-btn">CLOSE</button>
            </div>
        </div>
    </div>

    <script type="importmap">
    { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/" } }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

        // Firebase Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, getDocs, setDoc, onSnapshot, collection, serverTimestamp, query, writeBatch, addDoc, orderBy, limit } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        const appId = typeof __app_id !== 'undefined' ? __app_id : 'new-hack-city-dev';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : { apiKey: "dev", authDomain: "dev.firebaseapp.com", projectId: "dev" };
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        let userId = null;
        let playerStateUnsubscribe = null;
        let otherPlayersUnsubscribe = null;
        let chatUnsubscribe = null;

        let scene, camera, renderer, composer, labelRenderer, raycaster, bloomPass;
        const buildings = [], skyscraperMeshes = [];
        let dataPackets = [];
        const clock = new THREE.Clock();
        const moveState = { forward: 0, right: 0 };
        
        let cityGroup, currentLabyrinth;
        let isCityVisible = true;
        let currentInfiltratedBuilding = null;
        let gamePaused = true;

        const otherPlayers = new Map();
        let lastPositionUpdateTime = 0;
        const factions = {
            'Cipher Hackers': { color: '#f000ff' },
            'Data Kraken': { color: '#00ffde' },
            'Sovereign Key': { color: '#ff4400' }
        };

        let playerState = {
            level: 1,
            notoriety: 0,
            notorietyToNextLevel: 100,
            listenersAvailable: 5,
            deployedListenerCount: 0,
            infiltrations: 0,
            bounties: [],
            playerName: 'OFFLINE',
            faction: 'Unassigned',
            walletAddress: null
        };

        const abilities = {
            scan:     { btn: document.getElementById('scan-btn'),     cooldown: 10000, lastUsed: 0 },
            firewall: { btn: document.getElementById('firewall-btn'), cooldown: 60000, lastUsed: 0, duration: 20000, buffActive: false },
            drain:    { btn: document.getElementById('drain-btn'),    cooldown: 15000, lastUsed: 0, duration: 5000, active: false, position: new THREE.Vector3() },
            ghost:    { btn: document.getElementById('ghost-btn'),    cooldown: 30000, lastUsed: 0, duration: 10000, active: false },
            listener: { btn: document.getElementById('deploy-listener-btn'), cooldown: 2000, lastUsed: 0 }
        };
        
        const dApps = [
            { name: 'Axie Infinity', color: new THREE.Color('#49C3E0'), securityLevel: 4 },
            { name: 'The Machines Arena', color: new THREE.Color('#FF4400'), securityLevel: 3 },
            { name: 'Pixels', color: new THREE.Color('#7CFC00'), securityLevel: 2 },
            { name: 'Sunflower Land', color: new THREE.Color('#FFD700'), securityLevel: 1 },
            { name: 'Apeiron', color: new THREE.Color('#9400D3'), securityLevel: 3 },
            { name: 'Wild Forest', color: new THREE.Color('#228B22'), securityLevel: 2 },
            { name: 'Kaidro Chronicle', color: new THREE.Color('#FF1493'), securityLevel: 2 },
            { name: 'Ragnarok: Monster World', color: new THREE.Color('#FF6347'), securityLevel: 2 },
            { name: 'Puffverse', color: new THREE.Color('#FFC0CB'), securityLevel: 1 },
            { name: 'CyberKongz', color: new THREE.Color('#A0522D'), securityLevel: 2 },
            { name: 'Nifty Island', color: new THREE.Color('#87CEEB'), securityLevel: 1 },
            { name: 'Kuroro Beasts', color: new THREE.Color('#DAA520'), securityLevel: 2 },
            { name: 'CipherSwap', color: new THREE.Color('#f000ff'), securityLevel: 1 },
            { name: 'Ronin Financial', color: new THREE.Color('#0072FF'), securityLevel: 2 },
            { name: 'Sky Mavis HQ', color: new THREE.Color('#00ffde'), securityLevel: 4 }
        ];

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000005);
            scene.fog = new THREE.FogExp2(0x000005, 0.002);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 4000);
            camera.rotation.order = 'YXZ'; 
            raycaster = new THREE.Raycaster();
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            document.body.appendChild(renderer.domElement);
            labelRenderer = new CSS2DRenderer();
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.domElement.style.position = 'absolute';
            labelRenderer.domElement.style.top = '0px';
            labelRenderer.domElement.style.pointerEvents = 'none';
            document.body.appendChild(labelRenderer.domElement);
            
            setupMobileControls();
            setupAbilityControls();
            
            const ambient = new THREE.HemisphereLight(0xffffff, 0x444444, 0.5);
            scene.add(ambient);
            cityGroup = new THREE.Group();
            createNetworkFloor(cityGroup, renderer);
            const totalBuildings = 75; 
            const cityArea = 2000;
            for (let i = 0; i < totalBuildings; i++) {
                const hasLabel = i < dApps.length;
                const dApp = dApps[i % dApps.length];
                createSkyscraper(dApp, new THREE.Vector3((Math.random() - 0.5) * cityArea, 0, (Math.random() - 0.5) * cityArea), hasLabel);
            }
            scene.add(cityGroup);
            const renderPass = new RenderPass(scene, camera);
            bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.9, 0.4, 0.1);
            composer = new EffectComposer(renderer);
            composer.addPass(renderPass);
            composer.addPass(bloomPass);
            composer.addPass(new OutputPass());
            setInterval(generateDataTransfer, 200);
            setInterval(() => { if(abilities.ghost.active) return; const blip = document.getElementById('radar-blip'); blip.style.left = `${20 + Math.random() * 60}%`; blip.style.top = `${20 + Math.random() * 60}%`; blip.classList.toggle('active'); setTimeout(() => blip.classList.remove('active'), 500); }, 3000);
            setInterval(simulateHighPriorityData, 15000);
            setInterval(cleanupInactivePlayers, 15000); 
            setupModals();
            initPuzzle();
            returnToCity();
        }

        function returnToCity() {
            gamePaused = false;
            if(bloomPass) { bloomPass.strength = 0.9; bloomPass.threshold = 0.1; }
            isCityVisible = true;
            cityGroup.visible = true;
            otherPlayers.forEach(p => p.avatar.visible = true);
            document.getElementById('level-overlay').style.display = 'none';
            document.getElementById('puzzle-overlay').style.display = 'none';
            if (currentLabyrinth) { scene.remove(currentLabyrinth.group); }
            currentLabyrinth = null;
            currentInfiltratedBuilding = null;
            camera.position.set(0, 10, 50);
            camera.rotation.set(0, 0, 0);
        }

        function createSkyscraper(dApp, position, addLabel) {
            const height = Math.random() * 300 + 100, width = Math.random() * 40 + 25;
            const textureData = createScrollingCodeTexture(dApp.color.getHexString());
            const material = new THREE.MeshStandardMaterial({ color: 0x000000, emissive: dApp.color, emissiveMap: textureData.texture, toneMapped: false });
            const skyscraper = new THREE.Mesh(new THREE.BoxGeometry(width, height, width), material);
            skyscraper.position.set(position.x, height / 2, position.z);
            skyscraper.userData = { 
                name: dApp.name, 
                securityLevel: dApp.securityLevel,
                hasListener: false, 
                originalColor: material.emissive.clone(),
                isFlashing: false,
                isTarget: addLabel // Flag to know if this is a target or filler
            };
            cityGroup.add(skyscraper);
            if(addLabel) { // Only add to arrays if it's a target
                 buildings.push(textureData); 
                 skyscraperMeshes.push(skyscraper);
            }
           
            if (addLabel) {
                const labelDiv = document.createElement('div');
                labelDiv.className = 'label'; labelDiv.textContent = dApp.name;
                const cssColor = `#${dApp.color.getHexString()}`;
                labelDiv.style.borderColor = cssColor; labelDiv.style.color = cssColor;
                const nameLabel = new CSS2DObject(labelDiv);
                nameLabel.position.set(0, height / 2 + 20, 0);
                skyscraper.add(nameLabel);
                skyscraper.userData.label = nameLabel;
            }
        }

        function loadLabyrinthLevel(building) {
            if (currentLabyrinth || !building.userData.isTarget) return; // Only allow entering target buildings
            currentInfiltratedBuilding = building;
            if(bloomPass) { bloomPass.strength = 0.4; bloomPass.threshold = 0.5; }
            isCityVisible = false;
            cityGroup.visible = false;
            otherPlayers.forEach(p => p.avatar.visible = false);
            
            const floorCount = 2;
            currentLabyrinth = {
                group: new THREE.Group(),
                floors: [],
                currentFloor: 0,
            };
            
            for(let i = 0; i < floorCount; i++) {
                const yOffset = i * 200;
                const isFinal = (i === floorCount - 1);
                const floor = createLabyrinthFloor(building, yOffset, isFinal);
                currentLabyrinth.floors.push(floor);
                currentLabyrinth.group.add(floor.mazeGroup);
            }
            
            scene.add(currentLabyrinth.group);
            teleportToFloor(0);
        }

        function createLabyrinthFloor(building, yOffset, isFinal = false) {
            const mazeGroup = new THREE.Group();
            const obstacles = [];
            const mazeWalls = [];
            let openCoords = [];
            const mazeSize = 15, cellSize = 50, wallHeight = 20;
            const maze = generateMaze(mazeSize, mazeSize);

            const wallMaterial = new THREE.MeshStandardMaterial({ 
                color: building.material.emissive, emissive: building.material.emissive, 
                emissiveIntensity: 0.6, toneMapped: true, metalness: 0.2, roughness: 0.8 
            });
            const wallGeometry = new THREE.BoxGeometry(cellSize, wallHeight, cellSize);

            const securityLevel = building.userData.securityLevel || 1;
            const numSentries = securityLevel;
            const numLasers = Math.floor(securityLevel / 2);

            for (let i = 0; i < mazeSize; i++) {
                for (let j = 0; j < mazeSize; j++) {
                    const worldX = (j - mazeSize / 2) * cellSize;
                    const worldZ = (i - mazeSize / 2) * cellSize;
                    if (maze[i][j] === 1) {
                        const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                        wall.position.set(worldX, wallHeight / 2 + yOffset, worldZ);
                        mazeGroup.add(wall);
                        mazeWalls.push(wall);
                    } else {
                        openCoords.push(new THREE.Vector3(worldX, 5 + yOffset, worldZ));
                    }
                }
            }
            
            const startPos = new THREE.Vector3((-mazeSize/2 + 1.5) * cellSize, 10 + yOffset, (-mazeSize/2 + 1.5) * cellSize);
            const endPos = new THREE.Vector3((mazeSize/2 - 1.5) * cellSize, 10 + yOffset, (mazeSize/2 - 1.5) * cellSize);

            if(isFinal) {
                const vault = new THREE.Mesh(new THREE.BoxGeometry(20,20,20), new THREE.MeshStandardMaterial({color: 0xffffff, emissive: 0xaaaaaa, emissiveIntensity: 1}));
                vault.position.copy(endPos);
                vault.name = 'vault';
                mazeGroup.add(vault);
            } else {
                 const teleporter = new THREE.Mesh(new THREE.CylinderGeometry(10,10,1,32), new THREE.MeshBasicMaterial({color: 0x00ffde, transparent: true, opacity: 0.5}));
                 teleporter.position.copy(endPos).y = 0.1 + yOffset;
                 teleporter.name = 'teleporter';
                 mazeGroup.add(teleporter);
            }

            for(let i = 0; i < numSentries; i++) {
                if(openCoords.length > 2) {
                    const sentry = createSentry(openCoords.splice(Math.floor(Math.random() * openCoords.length), 1)[0]);
                    sentry.userData.path = [openCoords.splice(Math.floor(Math.random() * openCoords.length), 1)[0], openCoords.splice(Math.floor(Math.random() * openCoords.length), 1)[0]];
                    sentry.userData.pathProgress = 0;
                    sentry.userData.pathDirection = 1;
                    obstacles.push(sentry);
                    mazeGroup.add(sentry);
                }
            }
            
            for(let i = 0; i < numLasers; i++) {
                const laser = createLaser(new THREE.Vector3(-100, 10 + yOffset, -150 - (i * 50)), new THREE.Vector3(100, 10 + yOffset, -150 - (i * 50)));
                obstacles.push(laser);
                mazeGroup.add(laser.mesh);
            }
            
            return { mazeGroup, mazeWalls, startPos, endPos, obstacles };
        }

        function teleportToFloor(floorIndex) {
            if (!currentLabyrinth || !currentLabyrinth.floors[floorIndex]) return;
            currentLabyrinth.currentFloor = floorIndex;
            const floor = currentLabyrinth.floors[floorIndex];
            camera.position.copy(floor.startPos);
            camera.rotation.set(0, 0, 0);
        }

        function createSentry(position) {
            const sentry = new THREE.Mesh(new THREE.SphereGeometry(5, 8, 8), new THREE.MeshBasicMaterial({color: 0xff4400, wireframe: true}));
            sentry.position.copy(position);
            sentry.userData.type = 'sentry';
            return sentry;
        }

        function createLaser(start, end) {
            const material = new THREE.MeshBasicMaterial({color: 0xff4400, emissive: 0xff4400});
            const mesh = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, start.distanceTo(end), 8), material);
            mesh.position.copy(start).lerp(end, 0.5);
            mesh.lookAt(end);
            mesh.rotateX(Math.PI / 2);
            return { mesh, start, end, type: 'laser', progress: 0, direction: 1 };
        }
        
        function updateObstacles(delta) {
            if (!currentLabyrinth || gamePaused) return;
             currentLabyrinth.floors.forEach(floor => {
                 floor.obstacles.forEach(obs => {
                    if (obs.type === 'laser') {
                        obs.progress += delta * 0.5 * obs.direction;
                        if (obs.progress > 1 || obs.progress < 0) {
                            obs.direction *= -1;
                            obs.progress = Math.max(0, Math.min(1, obs.progress));
                        }
                        obs.mesh.position.lerpVectors(obs.start, obs.end, obs.progress);
                    } else if (obs.userData.type === 'sentry') {
                         if (obs.userData.path && obs.userData.path[0] && obs.userData.path[1]) {
                            obs.userData.pathProgress += delta * 0.2 * obs.userData.pathDirection;
                            if(obs.userData.pathProgress > 1 || obs.userData.pathProgress < 0) {
                                obs.userData.pathDirection *= -1;
                                obs.userData.pathProgress = Math.max(0, Math.min(1, obs.userData.pathProgress));
                            }
                            obs.position.lerpVectors(obs.userData.path[0], obs.userData.path[1], obs.userData.pathProgress);
                        }
                    }
                });
             });
        }
        
        let puzzleSequence = [], playerSequence = [], puzzleActive = false, puzzleButtons = [];
        
        function initPuzzle() {
            const grid = document.getElementById('puzzle-grid');
            grid.innerHTML = '';
            for (let i = 0; i < 9; i++) {
                const btn = document.createElement('div');
                btn.className = 'puzzle-btn';
                btn.dataset.id = i;
                btn.addEventListener('click', () => handlePuzzleClick(i));
                grid.appendChild(btn);
                puzzleButtons.push(btn);
            }
        }

        function startPuzzle() {
            gamePaused = true;
            puzzleActive = true;
            document.getElementById('puzzle-overlay').style.display = 'flex';
            puzzleSequence = [];
            playerSequence = [];
            const securityLevel = currentInfiltratedBuilding.userData.securityLevel || 1;
            const requiredLength = 3 + securityLevel;
            document.getElementById('puzzle-status').textContent = `Required sequence length: ${requiredLength}. Watch...`;
            addToPuzzleSequence(requiredLength);
        }

        function addToPuzzleSequence(requiredLength) {
            playerSequence = [];
            if (puzzleSequence.length < requiredLength) {
                puzzleSequence.push(Math.floor(Math.random() * 9));
            }
            playPuzzleSequence(requiredLength);
        }

        async function playPuzzleSequence(requiredLength) {
            for (const id of puzzleSequence) {
                await new Promise(resolve => setTimeout(resolve, 500));
                puzzleButtons[id].classList.add('lit');
                await new Promise(resolve => setTimeout(resolve, 500));
                puzzleButtons[id].classList.remove('lit');
            }
             document.getElementById('puzzle-status').textContent = `Your turn... (${puzzleSequence.length}/${requiredLength})`;
        }

        function handlePuzzleClick(id) {
            if (!puzzleActive || playerSequence.length >= puzzleSequence.length) return;
            playSound('sound-ui-click', 0.8);
            playerSequence.push(id);
            puzzleButtons[id].classList.add('lit');
            setTimeout(() => puzzleButtons[id].classList.remove('lit'), 200);
            
            const requiredLength = 3 + (currentInfiltratedBuilding.userData.securityLevel || 1);
            const lastIndex = playerSequence.length - 1;
            if (playerSequence[lastIndex] !== puzzleSequence[lastIndex]) {
                document.getElementById('puzzle-status').textContent = "Incorrect! Sequence restarting...";
                puzzleActive = false;
                setTimeout(() => startPuzzle(), 2000);
                return;
            }

            if (playerSequence.length === puzzleSequence.length) {
                if (puzzleSequence.length >= requiredLength) {
                    winPuzzle();
                } else {
                    setTimeout(() => addToPuzzleSequence(requiredLength), 1000);
                }
            }
        }

        function winPuzzle() {
            puzzleActive = false;
            gamePaused = true;
            document.getElementById('puzzle-overlay').style.display = 'none';

            playerState.infiltrations = (playerState.infiltrations || 0) + 1;

            let bountyCompleted = false;
            playerState.bounties.forEach(bounty => {
                if (!bounty.completed && bounty.type === 'infiltrate' && currentInfiltratedBuilding.userData.name === bounty.target) {
                    bounty.completed = true;
                    bountyCompleted = true;
                    addNotoriety(bounty.bonus);
                    showModal("Bounty Complete!", `+${bounty.bonus} Bonus Notoriety!`);
                    playSound('sound-bounty-complete');
                }
            });
            
            const securityLevel = currentInfiltratedBuilding.userData.securityLevel || 1;
            let baseNotoriety = (abilities.firewall.buffActive ? 50 : 25) * securityLevel;
            let listenerBonus = 0;
            let rewardHTML = '';

            if (currentInfiltratedBuilding && currentInfiltratedBuilding.userData.hasListener) {
                listenerBonus = 20 * securityLevel;
                rewardHTML += `<br>+${listenerBonus} Notoriety (Listener Bonus)`;
            }

            const nxsGain = (abilities.firewall.buffActive ? 20 : 10) * securityLevel;
            const fragmentsGain = (abilities.firewall.buffActive ? 10 : 5) * securityLevel;
            const totalNotorietyGain = baseNotoriety + listenerBonus;
            
            document.getElementById('level-message').innerHTML = 'SYSTEM INFILTRATED.';
            document.getElementById('reward-details').innerHTML = `REWARDS:<br>+${baseNotoriety} Notoriety` + rewardHTML + `<br>+${nxsGain} $NXS<br>+${fragmentsGain} Code Fragments`;
             
            if (abilities.firewall.buffActive) {
               document.getElementById('reward-details').innerHTML += `<br>(FIREWALL BUFF ACTIVE)`;
               abilities.firewall.buffActive = false;
               abilities.firewall.btn.classList.remove('buff-active');
            }
            addNotoriety(totalNotorietyGain);
            savePlayerState();
            document.getElementById('level-overlay').style.display = 'flex';
        }

        function handleMovement(delta) {
            if (gamePaused) return;
            const moveSpeed = (isCityVisible ? 150.0 : 60.0) * delta;
            
            const cameraDirection = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
            
            const moveVector = new THREE.Vector3();
            if (moveState.forward) moveVector.add(cameraDirection.clone().multiplyScalar(moveState.forward));
            if (moveState.right) moveVector.add(right.clone().multiplyScalar(moveState.right));
            
            if(moveVector.lengthSq() > 0) {
                moveVector.y = 0;
                moveVector.normalize();
                if (canMove(moveVector.clone())) {
                    camera.position.add(moveVector.multiplyScalar(moveSpeed));
                }
            }
        }

        function canMove(direction) {
            if (isCityVisible || !currentLabyrinth) return true;
            const floor = currentLabyrinth.floors[currentLabyrinth.currentFloor];
            if (!floor || !floor.mazeWalls) return true;
            
            raycaster.set(camera.position, direction);
            const intersections = raycaster.intersectObjects(floor.mazeWalls);
            
            return !(intersections.length > 0 && intersections[0].distance < 10);
        }

        function applyPenalty() {
            playSound('sound-penalty');
            showModal("Security Alert", "Infiltration failed. Notoriety lost.");
            addNotoriety(-10);
        }
        
        function checkProximity() {
            if (gamePaused) return;

            if (isCityVisible) {
                const playerBox = new THREE.Box3().setFromCenterAndSize(camera.position, new THREE.Vector3(1,1,1));
                for (const building of skyscraperMeshes) {
                    const buildingBox = new THREE.Box3().setFromObject(building);
                    if (playerBox.intersectsBox(buildingBox)) {
                        loadLabyrinthLevel(building);
                        return;
                    }
                }
            } else if (currentLabyrinth) {
                const floor = currentLabyrinth.floors[currentLabyrinth.currentFloor];
                const floorGroup = floor.mazeGroup;
                
                const vault = floorGroup.getObjectByName('vault');
                if (vault && camera.position.distanceTo(vault.position) < 20) {
                    startPuzzle();
                    return; 
                }
                
                const teleporter = floorGroup.getObjectByName('teleporter');
                if (teleporter && camera.position.distanceTo(teleporter.position) < 15) {
                    const nextFloorIndex = currentLabyrinth.currentFloor + 1;
                    if(nextFloorIndex < currentLabyrinth.floors.length) {
                        teleportToFloor(nextFloorIndex);
                    }
                    return;
                }
                
                for (const obs of floor.obstacles) {
                    const obsMesh = obs.type === 'laser' ? obs.mesh : obs;
                    if (camera.position.distanceTo(obsMesh.position) < 10) {
                        applyPenalty();
                        teleportToFloor(currentLabyrinth.currentFloor);
                        return;
                    }
                }
            }
        }
        
        function updateFlashingBuildings() {
            skyscraperMeshes.forEach(building => {
                if (building.userData.isFlashing) {
                    if (Date.now() > building.userData.flashEndTime) {
                        building.userData.isFlashing = false;
                        building.material.emissive.copy(building.userData.originalColor);
                    } else {
                        building.userData.flashCooldown -= clock.getDelta();
                        if (building.userData.flashCooldown <= 0) {
                            building.material.emissive.setHex(Math.random() * 0xffffff);
                            building.userData.flashCooldown = 0.3;
                        }
                    }
                }
            });
        }
        
        function animate() {
            requestAnimationFrame(animate);
            if (gamePaused) return;
            const delta = clock.getDelta();
            const now = performance.now();

            handleMovement(delta);
            checkProximity();
            updateObstacles(delta);
            
            if (userId && now - lastPositionUpdateTime > 100 && isCityVisible) {
                 updatePlayerPosition();
                 lastPositionUpdateTime = now;
            }
            
            otherPlayers.forEach(player => {
                if (player.targetPosition) {
                    player.avatar.position.lerp(player.targetPosition, 0.1);
                    player.avatar.quaternion.slerp(player.targetQuaternion, 0.1);
                }
            });

            if (isCityVisible) {
                updateDataTransfers();
                updateFlashingBuildings();
                buildings.forEach(updateTexture);
            }

            composer.render();
            labelRenderer.render(scene, camera);
        }
        
        function generateMaze(w, h) { const matrix = Array(h).fill(null).map(() => Array(w).fill(1)); const path = (r, c) => { matrix[r][c] = 0; const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]].sort(() => Math.random() - 0.5); for (const [dr, dc] of dirs) { const nr = r + dr * 2; const nc = c + dc * 2; if (nr > 0 && nr < h-1 && nc > 0 && nc < w-1 && matrix[nr][nc] === 1) { matrix[r + dr][c + dc] = 0; path(nr, nc); } } }; path(1,1); if(h > 2 && w > 2) matrix[h-2][w-2] = 0; return matrix; }
        
        function addNotoriety(amount) { 
            playerState.notoriety = Math.max(0, playerState.notoriety + amount); 
            let levelUp = false; 
            while(playerState.notoriety >= playerState.notorietyToNextLevel) { 
                levelUp = true; 
                playerState.level++; 
                playerState.notoriety -= playerState.notorietyToNextLevel; 
                playerState.notorietyToNextLevel = Math.floor(playerState.notorietyToNextLevel * 1.5); 
            } 
            if(levelUp) { 
                document.getElementById('player-level').textContent = `LVL ${playerState.level}`; 
                const msg = document.createElement('div'); 
                msg.textContent = `LEVEL UP! REACHED LEVEL ${playerState.level}!`; 
                msg.style.cssText = 'margin-top: 15px; color: #ff4400;'; 
                document.getElementById('level-message').appendChild(msg); 
            }
            savePlayerState();
        }
        
        function updateNotorietyBar() { 
            document.getElementById('notoriety-bar-fill').style.width = `${(playerState.notoriety / playerState.notorietyToNextLevel) * 100}%`; 
            document.getElementById('player-level').textContent = `LVL ${playerState.level}`;
        }
        
        function setupAbilityControls() { abilities.scan.btn.addEventListener('click', useScan); abilities.firewall.btn.addEventListener('click', useFirewall); abilities.drain.btn.addEventListener('click', useDataDrain); abilities.ghost.btn.addEventListener('click', useGhost); abilities.listener.btn.addEventListener('click', deployListener); }
        function handleCooldown(ability) { ability.lastUsed = Date.now(); ability.btn.classList.add('cooldown'); setTimeout(() => { ability.btn.classList.remove('cooldown'); }, ability.cooldown); }
        function useScan() { if (Date.now() - abilities.scan.lastUsed < abilities.scan.cooldown) return; playSound('sound-scan-ping'); handleCooldown(abilities.scan); skyscraperMeshes.forEach(b => { if (b.userData.label && camera.position.distanceTo(b.position) < 1000) { b.userData.label.element.classList.add('scan-highlight'); setTimeout(() => b.userData.label.element.classList.remove('scan-highlight'), 4000); } }); }
        function useFirewall() { if (Date.now() - abilities.firewall.lastUsed < abilities.firewall.cooldown || abilities.firewall.buffActive) return; playSound('sound-ui-click'); handleCooldown(abilities.firewall); abilities.firewall.buffActive = true; abilities.firewall.btn.classList.add('buff-active'); setTimeout(() => { if(abilities.firewall.buffActive) { abilities.firewall.buffActive = false; abilities.firewall.btn.classList.remove('buff-active'); } }, abilities.firewall.duration); }
        function useDataDrain() { if (Date.now() - abilities.drain.lastUsed < abilities.drain.cooldown || !isCityVisible) return; playSound('sound-ui-click'); handleCooldown(abilities.drain); abilities.drain.active = true; abilities.drain.position.copy(camera.position); setTimeout(() => { abilities.drain.active = false; }, abilities.drain.duration); }
        function useGhost() { if (Date.now() - abilities.ghost.lastUsed < abilities.ghost.cooldown || abilities.ghost.active) return; playSound('sound-ui-click'); handleCooldown(abilities.ghost); abilities.ghost.active = true; document.getElementById('radar').style.opacity = '0.2'; setTimeout(() => { abilities.ghost.active = false; document.getElementById('radar').style.opacity = '1'; }, abilities.ghost.duration); }
        
        function deployListener() {
            if (Date.now() - abilities.listener.lastUsed < abilities.listener.cooldown) return;
            if (playerState.listenersAvailable <= 0) { showModal("Out of Sync", "No listeners available."); return; }
            playSound('sound-ui-click');

            let closestBuilding = null;
            let minDistance = 100;

            for (const building of skyscraperMeshes) {
                const distance = camera.position.distanceTo(building.position);
                if (distance < minDistance) {
                    minDistance = distance;
                    closestBuilding = building;
                }
            }

            if (closestBuilding) {
                if (closestBuilding.userData.hasListener) {
                    showModal("Deployment Error", "Listener already deployed on this target.");
                    return;
                }
                handleCooldown(abilities.listener);
                playerState.listenersAvailable--;
                playerState.deployedListenerCount++;

                let bountyCompleted = false;
                playerState.bounties.forEach(bounty => {
                    if (!bounty.completed && bounty.type === 'deploy' && playerState.deployedListenerCount >= bounty.target) {
                        bounty.completed = true;
                        bountyCompleted = true;
                        addNotoriety(bounty.bonus);
                        showModal("Bounty Complete!", `+${bounty.bonus} Bonus Notoriety!`);
                        playSound('sound-bounty-complete');
                    }
                });
                
                closestBuilding.userData.hasListener = true;
                closestBuilding.userData.isFlashing = true;
                closestBuilding.userData.flashEndTime = Date.now() + 10000;
                closestBuilding.userData.flashCooldown = 0;
                
                const listenerDiv = document.createElement('div');
                listenerDiv.className = 'listener-icon';
                listenerDiv.textContent = '🔊';
                const listenerObj = new CSS2DObject(listenerDiv);
                listenerObj.position.set(0, closestBuilding.geometry.parameters.height / 2 + 50, 0);
                closestBuilding.add(listenerObj);
                closestBuilding.userData.listenerIcon = listenerObj;
                
                savePlayerState();

            } else {
                showModal("Targeting Error", "No target in range for listener deployment.");
            }
        }

        function updateListenerCount() {
            document.getElementById('listener-count').textContent = `Listeners: ${playerState.listenersAvailable} / 5`;
            if (playerState.listenersAvailable <= 0) {
                abilities.listener.btn.classList.add('disabled');
            } else {
                abilities.listener.btn.classList.remove('disabled');
            }
        }

        function simulateHighPriorityData() {
            const buggedBuildings = skyscraperMeshes.filter(b => b.userData.hasListener && !b.userData.isHighPriority);
            if(buggedBuildings.length === 0) return;

            skyscraperMeshes.forEach(b => {
                if(b.userData.isHighPriority) {
                    b.userData.isHighPriority = false;
                    if(b.userData.listenerIcon) {
                        b.userData.listenerIcon.element.classList.remove('high-priority');
                    }
                }
            });

            const targetBuilding = buggedBuildings[Math.floor(Math.random() * buggedBuildings.length)];
            targetBuilding.userData.isHighPriority = true;
            if (targetBuilding.userData.listenerIcon) {
                targetBuilding.userData.listenerIcon.element.classList.add('high-priority');
            }

            setTimeout(() => {
                if (targetBuilding.userData) {
                    targetBuilding.userData.isHighPriority = false;
                    if (targetBuilding.userData.listenerIcon) {
                        targetBuilding.userData.listenerIcon.element.classList.remove('high-priority');
                    }
                }
            }, 10000); 
        }

        function showModal(title, message) {
            const modal = document.getElementById('message-modal');
            modal.querySelector('#modal-title').textContent = title;
            modal.querySelector('#modal-text').textContent = message;
            modal.style.display = 'flex';
        }

        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight); labelRenderer.setSize(window.innerWidth, window.innerHeight); }
        
        function setupMobileControls() {
            const joyUp = document.getElementById('joy-up');
            const joyDown = document.getElementById('joy-down');
            const joyLeft = document.getElementById('joy-left');
            const joyRight = document.getElementById('joy-right');

            const startMove = (dir, val) => (e) => { e.preventDefault(); e.stopPropagation(); moveState[dir] = val; };
            const stopMove = () => { moveState.forward = 0; moveState.right = 0; };
            
            joyUp.addEventListener('touchstart', startMove('forward', 1), { passive: false });
            joyDown.addEventListener('touchstart', startMove('forward', -1), { passive: false });
            joyLeft.addEventListener('touchstart', startMove('right', -1), { passive: false });
            joyRight.addEventListener('touchstart', startMove('right', 1), { passive: false });

            joyUp.addEventListener('mousedown', startMove('forward', 1));
            joyDown.addEventListener('mousedown', startMove('forward', -1));
            joyLeft.addEventListener('mousedown', startMove('right', -1));
            joyRight.addEventListener('mousedown', startMove('right', 1));

            document.addEventListener('touchend', stopMove);
            document.addEventListener('mouseup', stopMove);

            let touchLookId = null;
            let lastLookX = 0, lastLookY = 0;

            renderer.domElement.addEventListener('touchstart', (e) => {
                for (const touch of e.changedTouches) {
                    if (touch.clientX > window.innerWidth / 2 && touchLookId === null) {
                        e.preventDefault();
                        touchLookId = touch.identifier;
                        lastLookX = touch.clientX;
                        lastLookY = touch.clientY;
                        return;
                    }
                }
            }, { passive: false });

            renderer.domElement.addEventListener('touchmove', (e) => {
                 for (const touch of e.changedTouches) {
                    if (touch.identifier === touchLookId) {
                        e.preventDefault();
                        const deltaX = touch.clientX - lastLookX;
                        const deltaY = touch.clientY - lastLookY;
                        lastLookX = touch.clientX;
                        lastLookY = touch.clientY;

                        camera.rotation.y -= deltaX * 0.002;
                        camera.rotation.x -= deltaY * 0.002;
                        camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
                    }
                }
            }, { passive: false });

            renderer.domElement.addEventListener('touchend', (e) => {
                for (const touch of e.changedTouches) {
                    if (touch.identifier === touchLookId) {
                        e.preventDefault();
                        touchLookId = null;
                        return;
                    }
                }
            });
        }
        
        function setupMovementControls() {}

        function createNetworkFloor(container, renderer) { const canvas = document.createElement('canvas'); canvas.width = 1024; canvas.height = 1024; const ctx = canvas.getContext('2d'); ctx.fillStyle = '#000510'; ctx.fillRect(0, 0, 1024, 1024); const gridStep = 50, pathColor = '#00ffff'; ctx.strokeStyle = pathColor; ctx.shadowColor = pathColor; ctx.lineWidth = 1; ctx.shadowBlur = 10; for (let x = 0; x < 1024; x += gridStep) { for (let y = 0; y < 1024; y += gridStep) { if (Math.random() > 0.5) { ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + (Math.random() - 0.5) * gridStep * 2, y + (Math.random() - 0.5) * gridStep * 2); ctx.stroke(); } } } const floorTexture = new THREE.CanvasTexture(canvas); floorTexture.wrapS = THREE.RepeatWrapping; floorTexture.wrapT = THREE.RepeatWrapping; floorTexture.repeat.set(15, 15); floorTexture.anisotropy = renderer.capabilities.getMaxAnisotropy(); const floor = new THREE.Mesh(new THREE.PlaneGeometry(8000, 8000), new THREE.MeshStandardMaterial({ map: floorTexture, emissiveMap: floorTexture, emissive: 0xccffff, emissiveIntensity: 0.4, roughness: 1.0, color: 0x000000 })); floor.rotation.x = -Math.PI / 2; floor.position.y = -0.5; container.add(floor); }
        function generateDataTransfer() { if (!isCityVisible || skyscraperMeshes.length < 2) return; const origin = skyscraperMeshes[Math.floor(Math.random() * skyscraperMeshes.length)].position; const target = skyscraperMeshes[Math.floor(Math.random() * skyscraperMeshes.length)].position; const packetGeometry = new THREE.SphereGeometry(2.5, 8, 8); const packetMaterial = new THREE.MeshBasicMaterial({ color: skyscraperMeshes[0].material.emissive, toneMapped: false }); const packetMesh = new THREE.Mesh(packetGeometry, packetMaterial); packetMesh.position.copy(origin).y = 2; const packet = { mesh: packetMesh, origin: packetMesh.position.clone(), target: target.clone().setY(2), progress: 0, speed: 0.005 + Math.random() * 0.005 }; dataPackets.push(packet); cityGroup.add(packetMesh); }
        function updateDataTransfers() { const drainAbility = abilities.drain; dataPackets.forEach((packet, i) => { let currentSpeed = packet.speed; if (drainAbility.active && packet.mesh.position.distanceTo(drainAbility.position) < 150) { currentSpeed *= 0.2; } packet.progress += currentSpeed; if (packet.progress >= 1) { cityGroup.remove(packet.mesh); packet.mesh.geometry.dispose(); packet.mesh.material.dispose(); dataPackets.splice(i, 1); } else packet.mesh.position.lerpVectors(packet.origin, packet.target, packet.progress); }); }
        function createScrollingCodeTexture(colorHex) { const canvas = document.createElement('canvas'), ctx = canvas.getContext('2d'); canvas.width = 256; canvas.height = 1024; const fontSize = 16; ctx.font = `bold ${fontSize}px monospace`; const chars = '0110101101001011101010100010101010101010101'; let code = ''; for (let i = 0; i < 20000; i++) code += chars[Math.floor(Math.random() * chars.length)]; return { canvas, context: ctx, texture: new THREE.CanvasTexture(canvas), code, fontSize, color: colorHex, scrollY: 0 }; }
        function updateTexture(data) { const { context, canvas, color, fontSize, code } = data; const charWidth = fontSize * 0.7, numColumns = Math.floor(canvas.width / charWidth), numRows = Math.floor(canvas.height / fontSize); context.fillStyle = '#000000'; context.fillRect(0, 0, canvas.width, canvas.height); context.fillStyle = `#${color}`; data.scrollY = (data.scrollY + numColumns) % code.length; for (let i = 0; i < numColumns; i++) { for (let j = 0; j < numRows; j++) { const charIndex = (data.scrollY + i * numRows + j) % code.length; context.fillText(code.charAt(charIndex), i * charWidth, j * fontSize); } } data.texture.needsUpdate = true; }
        
        async function connectAndStart() { 
            const btn = document.getElementById('connect-wallet-btn'); 
            btn.textContent = 'CONNECTING...'; 
            btn.disabled = true; 
            try {
                // Initialize the Ronin Widget
                const widget = new ronin.Widget({
                  appName: 'New Hack City',
                  appIcon: 'https://i.imgur.com/gcy0s2G.png',
                });

                await widget.connect();
                const accounts = await widget.getAccounts();
                if(!accounts || accounts.length === 0) {
                    throw new Error("No Ronin accounts found.");
                }
                playerState.walletAddress = accounts[0];


                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
                userId = auth.currentUser.uid;
                
                const playerDocRef = doc(db, 'artifacts', appId, 'users', userId, 'nhc_player_state', 'data');
                const playerDocSnap = await getDoc(playerDocRef);

                if (playerDocSnap.exists() && playerDocSnap.data().faction && playerDocSnap.data().faction !== 'Unassigned') {
                    await loadAndStartGame();
                } else {
                    showFactionChoice();
                }

            } catch (err) { 
                console.error("Failed to connect wallet or load data:", err); 
                showModal("Connection Error", "Could not connect Ronin Wallet. Please try again.");
                btn.textContent = 'Connect Ronin Wallet'; 
                btn.disabled = false; 
            } 
        }

        function setupModals() {
            document.getElementById('menu-toggle-btn').addEventListener('click', () => {
                const menu = document.getElementById('menu-panel');
                menu.style.display = menu.style.display === 'flex' ? 'none' : 'flex';
            });

            document.getElementById('chat-toggle-btn').addEventListener('click', () => {
                document.getElementById('chat-overlay').style.display = document.getElementById('chat-overlay').style.display === 'flex' ? 'none' : 'flex';
                document.getElementById('menu-panel').style.display = 'none';
            });
            
            document.getElementById('leaderboard-btn').addEventListener('click', openLeaderboard);
            document.getElementById('settings-btn').addEventListener('click', openSettingsModal);
            document.getElementById('refinement-btn').addEventListener('click', () => { showModal("Coming Soon", "The Refinement system is under development."); });
            
            document.querySelectorAll('.modal-close-btn').forEach(btn => {
                btn.onclick = () => {
                    const modal = btn.closest('.modal, #level-overlay, #faction-overlay');
                    if(modal) modal.style.display = 'none';
                    if(modal && modal.id === 'level-overlay') returnToCity();
                };
            });
            
            document.getElementById('chat-send-btn').addEventListener('click', sendChatMessage);
            document.getElementById('chat-input').addEventListener('keydown', (e) => {
                if (e.key === 'Enter') sendChatMessage();
            });
        }

        async function openLeaderboard() {
            const leaderboardOverlay = document.getElementById('leaderboard-overlay');
            leaderboardOverlay.style.display = 'flex';
            const list = document.getElementById('top-hackers-list');
            list.innerHTML = '<li>Loading...</li>';

            document.getElementById('personal-infiltrations').textContent = playerState.infiltrations || 0;
            
            try {
                const playersRef = collection(db, 'artifacts', appId, 'public/data/players');
                const snapshot = await getDocs(playersRef);
                
                let totalInfiltrations = 0;
                let playerCount = 0;
                const allPlayers = [];

                snapshot.forEach(doc => {
                    const data = doc.data();
                    if(data.infiltrations !== undefined) {
                        totalInfiltrations += data.infiltrations;
                        playerCount++;
                    }
                    allPlayers.push({ name: data.playerName || 'Hacker', score: data.infiltrations || 0 });
                });

                const average = playerCount > 0 ? (totalInfiltrations / playerCount) : 0;
                document.getElementById('average-infiltrations').textContent = average.toFixed(2);
                
                allPlayers.sort((a, b) => b.score - a.score);
                
                list.innerHTML = ''; 
                const top10 = allPlayers.slice(0, 10);
                
                if (top10.length === 0) {
                     list.innerHTML = '<li>No ranked players yet.</li>';
                } else {
                    top10.forEach((player, index) => {
                        const item = document.createElement('li');
                        item.innerHTML = `<span class="leaderboard-rank">${index + 1}.</span> <span class="leaderboard-name">${player.name}</span> <span class="leaderboard-score">${player.score}</span>`;
                        list.appendChild(item);
                    });
                }

            } catch(error) {
                console.error("Error fetching leaderboard data:", error);
                list.innerHTML = '<li>Error loading data.</li>';
            }
        }

        function openSettingsModal() {
            const settingsOverlay = document.getElementById('settings-overlay');
            const factionSection = document.getElementById('settings-faction-section');
            const nameInput = document.getElementById('name-change-input');
            nameInput.value = playerState.playerName || '';

            if (playerState.faction === 'Solo' || playerState.faction === 'Unassigned') {
                const choicesContainer = factionSection.querySelector('.faction-choices');
                choicesContainer.innerHTML = '';
                for(const factionName in factions) {
                    const btn = document.createElement('button');
                    btn.className = 'faction-btn';
                    btn.textContent = `Join ${factionName}`;
                    btn.style.borderColor = factions[factionName].color;
                    btn.style.textShadow = `0 0 8px ${factions[factionName].color}`;
                    btn.onclick = async () => {
                        playerState.faction = factionName;
                        await savePlayerState();
                        showModal("Faction Joined", `You are now a member of ${factionName}.`);
                        openSettingsModal();
                    };
                    choicesContainer.appendChild(btn);
                }
                factionSection.style.display = 'block';
            } else {
                factionSection.style.display = 'none';
            }
            
            settingsOverlay.style.display = 'flex';
            document.getElementById('settings-save-btn').onclick = async () => {
                const newName = nameInput.value.trim();
                if (newName && newName !== playerState.playerName) {
                    playerState.playerName = newName;
                }
                await savePlayerState();
                settingsOverlay.style.display = 'none';
                showModal("Settings Saved", "Your profile has been updated.");
            };
        }

        async function sendChatMessage() {
            const input = document.getElementById('chat-input');
            const message = input.value.trim();
            if(message === '' || !userId) return;

            const chatMessage = {
                userId: userId,
                playerName: playerState.playerName,
                faction: playerState.faction,
                message: message,
                timestamp: serverTimestamp()
            };

            try {
                await addDoc(collection(db, 'artifacts', appId, 'public/data/chat_messages'), chatMessage);
                input.value = '';
            } catch (error) {
                console.error("Error sending chat message:", error);
            }
        }

        function listenForChat() {
            if(chatUnsubscribe) chatUnsubscribe();
            const chatRef = collection(db, 'artifacts', appId, 'public/data/chat_messages');
            const q = query(chatRef, orderBy('timestamp', 'desc'), limit(50));
            
            chatUnsubscribe = onSnapshot(q, (snapshot) => {
                const messagesDiv = document.getElementById('chat-messages');
                messagesDiv.innerHTML = '';
                const messages = [];
                snapshot.forEach(doc => messages.push(doc.data()));
                messages.reverse().forEach(data => {
                    const msgEl = document.createElement('div');
                    msgEl.className = 'chat-message';
                    
                    const factionInfo = factions[data.faction] || { color: '#aaaaaa' };
                    const playerNameSpan = `<span style="color: ${factionInfo.color};">${data.playerName || 'Hacker'}:</span>`;
                    
                    msgEl.innerHTML = `${playerNameSpan} ${data.message}`;
                    messagesDiv.appendChild(msgEl);
                });
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
            });
        }


        function showFactionChoice() {
            const overlay = document.getElementById('faction-overlay');
            const choicesContainer = overlay.querySelector('.faction-choices');
            choicesContainer.innerHTML = '';

            for(const factionName in factions) {
                const btn = document.createElement('button');
                btn.className = 'faction-btn';
                btn.textContent = `Join ${factionName}`;
                btn.style.borderColor = factions[factionName].color;
                btn.style.textShadow = `0 0 8px ${factions[factionName].color}`;
                btn.onclick = () => selectFaction(factionName);
                choicesContainer.appendChild(btn);
            }

            const soloBtn = document.createElement('button');
            soloBtn.className = 'faction-btn';
            soloBtn.textContent = 'Play Solo';
            soloBtn.style.borderColor = '#888888';
            soloBtn.onclick = () => selectFaction('Solo');
            choicesContainer.appendChild(soloBtn);
            
            overlay.style.display = 'flex';
        }

        async function selectFaction(factionName) {
            playerState.faction = factionName;
            playerState.playerName = userId.substring(0, 8);
            playerState.infiltrations = 0;
            initializeBounties();
            await savePlayerState();
            document.getElementById('faction-overlay').style.display = 'none';
            await loadAndStartGame();
        }

        async function loadAndStartGame() {
            if (playerStateUnsubscribe) playerStateUnsubscribe(); 
            const playerDocRef = doc(db, 'artifacts', appId, 'users', userId, 'nhc_player_state', 'data');
            
            playerStateUnsubscribe = onSnapshot(playerDocRef, (snapshot) => {
                if(snapshot.exists()) {
                    Object.assign(playerState, snapshot.data());
                    updateAllUI();
                } else {
                    selectFaction('Solo');
                }
            });
            
            listenForOtherPlayers();
            listenForChat();

            document.getElementById('landing-overlay').style.display = 'none'; 
            playSound('sound-ambient', 0.3);
            gamePaused = false;
        }

        function listenForOtherPlayers() {
            const playersRef = collection(db, 'artifacts', appId, 'public/data/players');
            otherPlayersUnsubscribe = onSnapshot(playersRef, (snapshot) => {
                snapshot.docChanges().forEach((change) => {
                    const playerData = change.doc.data();
                    const changedUserId = change.doc.id;

                    if (changedUserId === userId) return;

                    if (change.type === "added" || change.type === "modified") {
                        if (!otherPlayers.has(changedUserId)) {
                            const playerAvatar = createPlayerAvatar(playerData);
                            scene.add(playerAvatar);
                            otherPlayers.set(changedUserId, { avatar: playerAvatar, data: playerData, targetPosition: new THREE.Vector3(), targetQuaternion: new THREE.Quaternion() });
                        }
                        
                        const player = otherPlayers.get(changedUserId);
                        player.data = playerData;
                        if(playerData.position) player.targetPosition.fromArray(playerData.position);
                        if(playerData.quaternion) player.targetQuaternion.fromArray(playerData.quaternion);
                        
                        const label = player.avatar.getObjectByProperty('type', 'CSS2DObject');
                        if (label) {
                            const factionInfo = factions[playerData.faction] || { color: '#aaaaaa' };
                            const factionDisplay = (playerData.faction && playerData.faction !== 'Solo' && playerData.faction !== 'Unassigned') ? `[${playerData.faction}]` : '';
                            label.element.innerHTML = `${playerData.playerName || 'Hacker'}<br>${factionDisplay}`;
                            label.element.style.color = factionInfo.color;
                            label.element.style.borderColor = factionInfo.color;
                        }
                    } else if (change.type === "removed") {
                        removePlayer(changedUserId);
                    }
                });
            });
        }
        
        function removePlayer(playerId) {
            if (otherPlayers.has(playerId)) {
                const player = otherPlayers.get(playerId);
                scene.remove(player.avatar);
                player.avatar.traverse(obj => {
                    if(obj.geometry) obj.geometry.dispose();
                    if(obj.material) obj.material.dispose();
                });
                otherPlayers.delete(playerId);
            }
        }

        function createPlayerAvatar(playerData) {
            const factionInfo = factions[playerData.faction] || {color: '#aaaaaa'};
            const group = new THREE.Group();
            
            const bodyGeo = new THREE.CapsuleGeometry(2, 6, 4, 8);
            const bodyMat = new THREE.MeshStandardMaterial({
                color: new THREE.Color(factionInfo.color),
                emissive: new THREE.Color(factionInfo.color),
                emissiveIntensity: 0.5,
                metalness: 0.3,
                roughness: 0.6,
                transparent: true,
                opacity: 0.7
            });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 5;
            group.add(body);
            
            const labelDiv = document.createElement('div');
            labelDiv.className = 'player-label';
            const factionDisplay = (playerData.faction && playerData.faction !== 'Solo' && playerData.faction !== 'Unassigned') ? `[${playerData.faction}]` : '';
            labelDiv.innerHTML = `${playerData.playerName || 'Hacker'}<br>${factionDisplay}`;
            labelDiv.style.color = factionInfo.color;
            labelDiv.style.borderColor = factionInfo.color;
            const nameLabel = new CSS2DObject(labelDiv);
            nameLabel.position.set(0, 12, 0); 
            group.add(nameLabel);
            
            if(playerData.position) group.position.fromArray(playerData.position);
            return group;
        }

        function cleanupInactivePlayers() {
            if (otherPlayers.size === 0) return;
            const now = Date.now();
            const timeout = 30000;
            const toDelete = [];
            otherPlayers.forEach((player, pId) => {
                if(player.data.lastSeen && player.data.lastSeen.toDate()){
                   if(now - player.data.lastSeen.toDate().getTime() > timeout) {
                       toDelete.push(pId);
                   }
                }
            });

            if (toDelete.length > 0) {
                 const batch = writeBatch(db);
                 toDelete.forEach(pId => {
                    const playerDocRef = doc(db, 'artifacts', appId, 'public/data/players', pId);
                    batch.delete(playerDocRef);
                    removePlayer(pId);
                 });
                 batch.commit().catch(e => console.error("Error cleaning up players:", e));
            }
        }


        document.getElementById('connect-wallet-btn').addEventListener('click', connectAndStart);
        window.addEventListener('resize', onWindowResize);
        
        init();
        animate();
    </script>
</body>
</html>
